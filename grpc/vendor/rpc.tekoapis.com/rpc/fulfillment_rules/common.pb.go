// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/fulfillment_rules/v1/common.proto

package fulfillment_rules

import (
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Inventory required fields because every order must have a fallback inventory code
type Inventory struct {
	Northern             string   `protobuf:"bytes,1,opt,name=northern,proto3" json:"northern,omitempty"`
	Central              string   `protobuf:"bytes,2,opt,name=central,proto3" json:"central,omitempty"`
	Southern             string   `protobuf:"bytes,3,opt,name=southern,proto3" json:"southern,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Inventory) Reset()         { *m = Inventory{} }
func (m *Inventory) String() string { return proto.CompactTextString(m) }
func (*Inventory) ProtoMessage()    {}
func (*Inventory) Descriptor() ([]byte, []int) {
	return fileDescriptor_4963a02de2c32f58, []int{0}
}
func (m *Inventory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inventory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inventory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inventory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inventory.Merge(m, src)
}
func (m *Inventory) XXX_Size() int {
	return m.Size()
}
func (m *Inventory) XXX_DiscardUnknown() {
	xxx_messageInfo_Inventory.DiscardUnknown(m)
}

var xxx_messageInfo_Inventory proto.InternalMessageInfo

func (m *Inventory) GetNorthern() string {
	if m != nil {
		return m.Northern
	}
	return ""
}

func (m *Inventory) GetCentral() string {
	if m != nil {
		return m.Central
	}
	return ""
}

func (m *Inventory) GetSouthern() string {
	if m != nil {
		return m.Southern
	}
	return ""
}

// Seller
type Seller struct {
	Id                   uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SellerCenterId       uint32     `protobuf:"varint,2,opt,name=seller_center_id,proto3" json:"seller_center_id,omitempty"`
	Code                 string     `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
	IsAllowAutoProcess   bool       `protobuf:"varint,4,opt,name=is_allow_auto_process,proto3" json:"is_allow_auto_process,omitempty"`
	IsImportWithoutStore bool       `protobuf:"varint,5,opt,name=is_import_without_store,proto3" json:"is_import_without_store,omitempty"`
	FirebasePath         string     `protobuf:"bytes,6,opt,name=firebase_path,proto3" json:"firebase_path,omitempty"`
	DefaultInventory     *Inventory `protobuf:"bytes,7,opt,name=default_inventory,proto3" json:"default_inventory,omitempty"`
	// payment_epsilon: max amount of money deviation allowed to fully paid
	PaymentEpsilon uint64 `protobuf:"varint,8,opt,name=payment_epsilon,proto3" json:"payment_epsilon,omitempty"`
	// is_skip_coupon: is allowed allocate promotion by coupon
	IsSkipCoupon bool `protobuf:"varint,9,opt,name=is_skip_coupon,proto3" json:"is_skip_coupon,omitempty"`
	// is_allocate_order_promotion: is allowed allocate promotion by whole order
	IsAllocateOrderPromotion bool `protobuf:"varint,10,opt,name=is_allocate_order_promotion,proto3" json:"is_allocate_order_promotion,omitempty"`
	// is_allocate_none_order_promotion: is allowed allocate promotion by each items in the order
	IsAllocateNoneOrderPromotion bool     `protobuf:"varint,11,opt,name=is_allocate_none_order_promotion,proto3" json:"is_allocate_none_order_promotion,omitempty"`
	IsApplyRelativeAllocation    bool     `protobuf:"varint,12,opt,name=is_apply_relative_allocation,proto3" json:"is_apply_relative_allocation,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *Seller) Reset()         { *m = Seller{} }
func (m *Seller) String() string { return proto.CompactTextString(m) }
func (*Seller) ProtoMessage()    {}
func (*Seller) Descriptor() ([]byte, []int) {
	return fileDescriptor_4963a02de2c32f58, []int{1}
}
func (m *Seller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Seller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Seller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Seller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Seller.Merge(m, src)
}
func (m *Seller) XXX_Size() int {
	return m.Size()
}
func (m *Seller) XXX_DiscardUnknown() {
	xxx_messageInfo_Seller.DiscardUnknown(m)
}

var xxx_messageInfo_Seller proto.InternalMessageInfo

func (m *Seller) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Seller) GetSellerCenterId() uint32 {
	if m != nil {
		return m.SellerCenterId
	}
	return 0
}

func (m *Seller) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Seller) GetIsAllowAutoProcess() bool {
	if m != nil {
		return m.IsAllowAutoProcess
	}
	return false
}

func (m *Seller) GetIsImportWithoutStore() bool {
	if m != nil {
		return m.IsImportWithoutStore
	}
	return false
}

func (m *Seller) GetFirebasePath() string {
	if m != nil {
		return m.FirebasePath
	}
	return ""
}

func (m *Seller) GetDefaultInventory() *Inventory {
	if m != nil {
		return m.DefaultInventory
	}
	return nil
}

func (m *Seller) GetPaymentEpsilon() uint64 {
	if m != nil {
		return m.PaymentEpsilon
	}
	return 0
}

func (m *Seller) GetIsSkipCoupon() bool {
	if m != nil {
		return m.IsSkipCoupon
	}
	return false
}

func (m *Seller) GetIsAllocateOrderPromotion() bool {
	if m != nil {
		return m.IsAllocateOrderPromotion
	}
	return false
}

func (m *Seller) GetIsAllocateNoneOrderPromotion() bool {
	if m != nil {
		return m.IsAllocateNoneOrderPromotion
	}
	return false
}

func (m *Seller) GetIsApplyRelativeAllocation() bool {
	if m != nil {
		return m.IsApplyRelativeAllocation
	}
	return false
}

// Address
type Address struct {
	ApartmentNumber      string   `protobuf:"bytes,1,opt,name=apartment_number,proto3" json:"apartment_number,omitempty"`
	Street               string   `protobuf:"bytes,2,opt,name=street,proto3" json:"street,omitempty"`
	Ward                 string   `protobuf:"bytes,3,opt,name=ward,proto3" json:"ward,omitempty"`
	District             string   `protobuf:"bytes,4,opt,name=district,proto3" json:"district,omitempty"`
	City                 string   `protobuf:"bytes,5,opt,name=city,proto3" json:"city,omitempty"`
	Province             string   `protobuf:"bytes,6,opt,name=province,proto3" json:"province,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_4963a02de2c32f58, []int{2}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetApartmentNumber() string {
	if m != nil {
		return m.ApartmentNumber
	}
	return ""
}

func (m *Address) GetStreet() string {
	if m != nil {
		return m.Street
	}
	return ""
}

func (m *Address) GetWard() string {
	if m != nil {
		return m.Ward
	}
	return ""
}

func (m *Address) GetDistrict() string {
	if m != nil {
		return m.District
	}
	return ""
}

func (m *Address) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *Address) GetProvince() string {
	if m != nil {
		return m.Province
	}
	return ""
}

// Shipping
type ShippingAddress struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Phone                string   `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	Note                 string   `protobuf:"bytes,4,opt,name=note,proto3" json:"note,omitempty"`
	Address              *Address `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShippingAddress) Reset()         { *m = ShippingAddress{} }
func (m *ShippingAddress) String() string { return proto.CompactTextString(m) }
func (*ShippingAddress) ProtoMessage()    {}
func (*ShippingAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_4963a02de2c32f58, []int{3}
}
func (m *ShippingAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShippingAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShippingAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShippingAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShippingAddress.Merge(m, src)
}
func (m *ShippingAddress) XXX_Size() int {
	return m.Size()
}
func (m *ShippingAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_ShippingAddress.DiscardUnknown(m)
}

var xxx_messageInfo_ShippingAddress proto.InternalMessageInfo

func (m *ShippingAddress) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ShippingAddress) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ShippingAddress) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *ShippingAddress) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *ShippingAddress) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

// User
type User struct {
	Id                   uint32             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Phone                string             `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	Email                string             `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
	ShippingAddress      []*ShippingAddress `protobuf:"bytes,5,rep,name=shipping_address,proto3" json:"shipping_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_4963a02de2c32f58, []int{4}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetShippingAddress() []*ShippingAddress {
	if m != nil {
		return m.ShippingAddress
	}
	return nil
}

// ShippingFeeRule
type ShippingFeeRule struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Rule                 string   `protobuf:"bytes,2,opt,name=rule,proto3" json:"rule,omitempty"`
	Fee                  uint64   `protobuf:"varint,3,opt,name=fee,proto3" json:"fee,omitempty"`
	Priority             uint32   `protobuf:"varint,4,opt,name=priority,proto3" json:"priority,omitempty"`
	Comment              string   `protobuf:"bytes,5,opt,name=comment,proto3" json:"comment,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShippingFeeRule) Reset()         { *m = ShippingFeeRule{} }
func (m *ShippingFeeRule) String() string { return proto.CompactTextString(m) }
func (*ShippingFeeRule) ProtoMessage()    {}
func (*ShippingFeeRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_4963a02de2c32f58, []int{5}
}
func (m *ShippingFeeRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShippingFeeRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShippingFeeRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShippingFeeRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShippingFeeRule.Merge(m, src)
}
func (m *ShippingFeeRule) XXX_Size() int {
	return m.Size()
}
func (m *ShippingFeeRule) XXX_DiscardUnknown() {
	xxx_messageInfo_ShippingFeeRule.DiscardUnknown(m)
}

var xxx_messageInfo_ShippingFeeRule proto.InternalMessageInfo

func (m *ShippingFeeRule) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ShippingFeeRule) GetRule() string {
	if m != nil {
		return m.Rule
	}
	return ""
}

func (m *ShippingFeeRule) GetFee() uint64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *ShippingFeeRule) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *ShippingFeeRule) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func init() {
	proto.RegisterType((*Inventory)(nil), "fulfillment_rules.v1.Inventory")
	proto.RegisterType((*Seller)(nil), "fulfillment_rules.v1.Seller")
	proto.RegisterType((*Address)(nil), "fulfillment_rules.v1.Address")
	proto.RegisterType((*ShippingAddress)(nil), "fulfillment_rules.v1.ShippingAddress")
	proto.RegisterType((*User)(nil), "fulfillment_rules.v1.User")
	proto.RegisterType((*ShippingFeeRule)(nil), "fulfillment_rules.v1.ShippingFeeRule")
}

func init() {
	proto.RegisterFile("proto/fulfillment_rules/v1/common.proto", fileDescriptor_4963a02de2c32f58)
}

var fileDescriptor_4963a02de2c32f58 = []byte{
	// 784 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0x41, 0x73, 0x1b, 0x35,
	0x14, 0xee, 0x3a, 0xeb, 0xd8, 0x51, 0x68, 0x6b, 0x34, 0x81, 0xec, 0x34, 0x34, 0xf5, 0x98, 0x52,
	0xb6, 0x65, 0xb0, 0x6b, 0x97, 0x83, 0xb9, 0x51, 0x1f, 0x98, 0x81, 0x1b, 0xdb, 0x61, 0x98, 0x81,
	0x14, 0x8d, 0xb2, 0xfb, 0x8c, 0x35, 0xd5, 0x4a, 0x1a, 0x49, 0xeb, 0x8c, 0xa7, 0xcd, 0x95, 0x03,
	0xbf, 0x80, 0xdf, 0xc1, 0x1f, 0xe0, 0xca, 0x91, 0x23, 0x47, 0x26, 0xfc, 0x8b, 0x9c, 0x18, 0x69,
	0x77, 0x6d, 0x27, 0x76, 0xd3, 0x9b, 0xde, 0xd3, 0xf7, 0xbd, 0xfd, 0xde, 0xd3, 0x27, 0x2d, 0xfa,
	0x54, 0x69, 0x69, 0xe5, 0x60, 0x5a, 0xf0, 0x29, 0xe3, 0x3c, 0x07, 0x61, 0x89, 0x2e, 0x38, 0x98,
	0xc1, 0x7c, 0x38, 0x48, 0x65, 0x9e, 0x4b, 0xd1, 0xf7, 0x08, 0x7c, 0xb0, 0x01, 0xe9, 0xcf, 0x87,
	0xf7, 0x0e, 0xe7, 0x94, 0xb3, 0x8c, 0x5a, 0x18, 0xd4, 0x8b, 0x12, 0xde, 0x7b, 0x89, 0xf6, 0xbe,
	0x11, 0x73, 0x10, 0x56, 0xea, 0x05, 0xbe, 0x87, 0xda, 0x42, 0x6a, 0x3b, 0x03, 0x2d, 0xa2, 0xa0,
	0x1b, 0xc4, 0x7b, 0xc9, 0x32, 0xc6, 0x11, 0x6a, 0xa5, 0x20, 0xac, 0xa6, 0x3c, 0x6a, 0xf8, 0xad,
	0x3a, 0x74, 0x2c, 0x23, 0x8b, 0x92, 0xb5, 0x53, 0xb2, 0xea, 0xb8, 0xf7, 0x6b, 0x13, 0xed, 0xbe,
	0x00, 0xce, 0x41, 0xe3, 0x43, 0xd4, 0x60, 0x99, 0x2f, 0x7b, 0x7b, 0xd2, 0xba, 0x9c, 0x84, 0x4f,
	0x1a, 0xdd, 0x5b, 0x49, 0x83, 0x65, 0xf8, 0x19, 0xea, 0x18, 0x0f, 0x21, 0xae, 0x22, 0x68, 0xc2,
	0x32, 0xff, 0x89, 0x35, 0xd8, 0x06, 0x00, 0x1f, 0xa1, 0x30, 0x95, 0x19, 0x94, 0x1f, 0xf4, 0x40,
	0xdd, 0xe8, 0x04, 0x89, 0x4f, 0xe2, 0x2f, 0xd0, 0x07, 0xcc, 0x10, 0xca, 0xb9, 0x3c, 0x23, 0xb4,
	0xb0, 0x92, 0x28, 0x2d, 0x53, 0x30, 0x26, 0x0a, 0xbb, 0x41, 0xdc, 0x4e, 0xb6, 0x6f, 0xe2, 0x31,
	0x3a, 0x64, 0x86, 0xb0, 0x5c, 0x49, 0x6d, 0xc9, 0x19, 0xb3, 0x33, 0x59, 0x58, 0x62, 0xac, 0xd4,
	0x10, 0x35, 0x3d, 0xef, 0x6d, 0xdb, 0xf8, 0x21, 0xba, 0x3d, 0x65, 0x1a, 0x4e, 0xa9, 0x01, 0xa2,
	0xa8, 0x9d, 0x45, 0xbb, 0x7e, 0x0c, 0x57, 0x93, 0xf8, 0x07, 0xf4, 0x7e, 0x06, 0x53, 0x5a, 0x70,
	0x4b, 0x58, 0x3d, 0xf2, 0xa8, 0xd5, 0x0d, 0xe2, 0xfd, 0xd1, 0x83, 0xfe, 0xb6, 0x53, 0xeb, 0x2f,
	0x4f, 0x66, 0xd2, 0xbe, 0x9c, 0x34, 0x7f, 0x0b, 0x5c, 0x87, 0x9b, 0x35, 0x70, 0x8c, 0xee, 0x2a,
	0xba, 0xf0, 0x54, 0x50, 0x86, 0x71, 0x29, 0xa2, 0x76, 0x37, 0x88, 0xc3, 0xe4, 0x7a, 0x1a, 0x3f,
	0x42, 0x77, 0x98, 0x21, 0xe6, 0x15, 0x53, 0x24, 0x95, 0x85, 0x92, 0x22, 0xda, 0xf3, 0x9d, 0x5d,
	0xcb, 0xe2, 0xaf, 0xd0, 0x51, 0x35, 0xa3, 0x94, 0x5a, 0x20, 0x52, 0x67, 0xa0, 0xdd, 0x9c, 0x72,
	0x69, 0x99, 0x14, 0x11, 0xf2, 0xa4, 0x9b, 0x20, 0xf8, 0x5b, 0xd4, 0x5d, 0xdf, 0x16, 0x52, 0x6c,
	0x96, 0xd9, 0xf7, 0x65, 0xde, 0x89, 0xc3, 0x13, 0xf4, 0x91, 0xc3, 0x28, 0xc5, 0x17, 0x44, 0x03,
	0xa7, 0x96, 0xcd, 0xa1, 0xa6, 0xb8, 0x3a, 0xef, 0xf9, 0x3a, 0x37, 0x62, 0x7a, 0x7f, 0x06, 0xa8,
	0xf5, 0x3c, 0xcb, 0xb4, 0x3b, 0xe8, 0x27, 0xa8, 0x43, 0x15, 0xd5, 0xd6, 0x8f, 0x46, 0x14, 0xf9,
	0x29, 0xe8, 0xca, 0xee, 0x1b, 0x79, 0xfc, 0x21, 0xda, 0x35, 0x56, 0x03, 0xd8, 0xca, 0xf5, 0x55,
	0x84, 0x31, 0x0a, 0xcf, 0xa8, 0xce, 0x2a, 0xc3, 0xfb, 0xb5, 0xbb, 0x08, 0x19, 0x33, 0x56, 0xb3,
	0xd4, 0x7a, 0xa7, 0xed, 0x25, 0xcb, 0xd8, 0xfb, 0x95, 0xd9, 0x85, 0x77, 0xd2, 0x15, 0xbf, 0x32,
	0xbb, 0xc0, 0x1f, 0xa3, 0xb6, 0xd2, 0x72, 0xce, 0x44, 0x0a, 0xa5, 0x75, 0x56, 0x80, 0xe5, 0x46,
	0xef, 0x9f, 0x00, 0xdd, 0x7d, 0x31, 0x63, 0x4a, 0x31, 0xf1, 0x4b, 0xdd, 0xc9, 0x5b, 0xef, 0xd4,
	0x11, 0x0a, 0x05, 0xcd, 0xa1, 0x14, 0xbd, 0xf6, 0x39, 0x97, 0xc4, 0x63, 0xd4, 0x54, 0x33, 0x29,
	0xea, 0xcb, 0xd3, 0xbb, 0x9c, 0x3c, 0xd0, 0xf7, 0x47, 0x47, 0x3f, 0xc7, 0x4f, 0xdf, 0x9c, 0x7c,
	0xf6, 0xf8, 0xa7, 0xe1, 0xe7, 0x5f, 0xbe, 0x8c, 0x4f, 0xb2, 0xd7, 0xe3, 0xf3, 0x37, 0x27, 0xd9,
	0xeb, 0xe1, 0xd3, 0xf3, 0xc7, 0x0f, 0x93, 0x92, 0xe0, 0xba, 0x16, 0xd2, 0x42, 0xd5, 0x9d, 0x5f,
	0xe3, 0xe7, 0xa8, 0x45, 0x4b, 0x39, 0xbe, 0xb9, 0xfd, 0xd1, 0xfd, 0xed, 0x66, 0xae, 0x34, 0xaf,
	0x59, 0xb9, 0xe6, 0xf5, 0xfe, 0x08, 0x50, 0xf8, 0xbd, 0xb9, 0xe9, 0x8d, 0xc0, 0xeb, 0xfd, 0x54,
	0x6d, 0x1c, 0x5c, 0x69, 0xa3, 0x96, 0x78, 0x80, 0x9a, 0x90, 0x53, 0xc6, 0x2b, 0x8d, 0x65, 0x80,
	0xbf, 0x43, 0x1d, 0x53, 0xcd, 0x8e, 0xac, 0xd4, 0xee, 0xc4, 0xfb, 0xa3, 0x4f, 0xb6, 0xab, 0xbd,
	0x36, 0xe9, 0x64, 0x83, 0xde, 0x3b, 0x5f, 0x1d, 0xc7, 0xd7, 0x00, 0x49, 0xc1, 0x01, 0xdf, 0x59,
	0xc9, 0xaf, 0x55, 0xbb, 0x82, 0xb5, 0x6a, 0xb7, 0xc6, 0x1d, 0xb4, 0x33, 0x85, 0x52, 0x73, 0x98,
	0xb8, 0xa5, 0xb3, 0x8d, 0xd2, 0x4c, 0x6a, 0x67, 0x8f, 0xd0, 0x73, 0x97, 0xb1, 0x7f, 0x75, 0x65,
	0xee, 0xa4, 0x95, 0xce, 0x49, 0xea, 0x70, 0x32, 0xfe, 0xeb, 0xe2, 0x38, 0xf8, 0xfb, 0xe2, 0x38,
	0xf8, 0xf7, 0xe2, 0x38, 0xf8, 0xfd, 0xbf, 0xe3, 0x5b, 0x3f, 0x3e, 0xd2, 0x2a, 0xed, 0x5b, 0x78,
	0x25, 0xa9, 0x62, 0xa6, 0x9f, 0xca, 0x7c, 0xa0, 0x55, 0xba, 0xf9, 0xc7, 0x38, 0xdd, 0xf5, 0x2f,
	0xff, 0xb3, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x65, 0x82, 0x17, 0xab, 0x53, 0x06, 0x00, 0x00,
}

func (m *Inventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inventory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inventory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Southern) > 0 {
		i -= len(m.Southern)
		copy(dAtA[i:], m.Southern)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Southern)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Central) > 0 {
		i -= len(m.Central)
		copy(dAtA[i:], m.Central)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Central)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Northern) > 0 {
		i -= len(m.Northern)
		copy(dAtA[i:], m.Northern)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Northern)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Seller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Seller) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Seller) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsApplyRelativeAllocation {
		i--
		if m.IsApplyRelativeAllocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IsAllocateNoneOrderPromotion {
		i--
		if m.IsAllocateNoneOrderPromotion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsAllocateOrderPromotion {
		i--
		if m.IsAllocateOrderPromotion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IsSkipCoupon {
		i--
		if m.IsSkipCoupon {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.PaymentEpsilon != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PaymentEpsilon))
		i--
		dAtA[i] = 0x40
	}
	if m.DefaultInventory != nil {
		{
			size, err := m.DefaultInventory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FirebasePath) > 0 {
		i -= len(m.FirebasePath)
		copy(dAtA[i:], m.FirebasePath)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.FirebasePath)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsImportWithoutStore {
		i--
		if m.IsImportWithoutStore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IsAllowAutoProcess {
		i--
		if m.IsAllowAutoProcess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SellerCenterId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SellerCenterId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Province) > 0 {
		i -= len(m.Province)
		copy(dAtA[i:], m.Province)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Province)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.District) > 0 {
		i -= len(m.District)
		copy(dAtA[i:], m.District)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.District)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ward) > 0 {
		i -= len(m.Ward)
		copy(dAtA[i:], m.Ward)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Ward)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Street) > 0 {
		i -= len(m.Street)
		copy(dAtA[i:], m.Street)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Street)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApartmentNumber) > 0 {
		i -= len(m.ApartmentNumber)
		copy(dAtA[i:], m.ApartmentNumber)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ApartmentNumber)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShippingAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShippingAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Note) > 0 {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShippingAddress) > 0 {
		for iNdEx := len(m.ShippingAddress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShippingAddress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShippingFeeRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingFeeRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShippingFeeRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Priority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x20
	}
	if m.Fee != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Fee))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Rule) > 0 {
		i -= len(m.Rule)
		copy(dAtA[i:], m.Rule)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Rule)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Inventory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Northern)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Central)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Southern)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Seller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.SellerCenterId != 0 {
		n += 1 + sovCommon(uint64(m.SellerCenterId))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.IsAllowAutoProcess {
		n += 2
	}
	if m.IsImportWithoutStore {
		n += 2
	}
	l = len(m.FirebasePath)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.DefaultInventory != nil {
		l = m.DefaultInventory.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PaymentEpsilon != 0 {
		n += 1 + sovCommon(uint64(m.PaymentEpsilon))
	}
	if m.IsSkipCoupon {
		n += 2
	}
	if m.IsAllocateOrderPromotion {
		n += 2
	}
	if m.IsAllocateNoneOrderPromotion {
		n += 2
	}
	if m.IsApplyRelativeAllocation {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApartmentNumber)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Street)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Ward)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.District)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Province)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShippingAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.ShippingAddress) > 0 {
		for _, e := range m.ShippingAddress {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShippingFeeRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Rule)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Fee != 0 {
		n += 1 + sovCommon(uint64(m.Fee))
	}
	if m.Priority != 0 {
		n += 1 + sovCommon(uint64(m.Priority))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Inventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Northern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Northern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Central", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Central = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Southern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Southern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Seller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Seller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Seller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerCenterId", wireType)
			}
			m.SellerCenterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerCenterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllowAutoProcess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllowAutoProcess = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsImportWithoutStore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsImportWithoutStore = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirebasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirebasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultInventory == nil {
				m.DefaultInventory = &Inventory{}
			}
			if err := m.DefaultInventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentEpsilon", wireType)
			}
			m.PaymentEpsilon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentEpsilon |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSkipCoupon", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSkipCoupon = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllocateOrderPromotion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllocateOrderPromotion = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllocateNoneOrderPromotion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllocateNoneOrderPromotion = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsApplyRelativeAllocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsApplyRelativeAllocation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApartmentNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApartmentNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ward = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field District", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.District = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Province", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Province = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingAddress = append(m.ShippingAddress, &ShippingAddress{})
			if err := m.ShippingAddress[len(m.ShippingAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingFeeRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingFeeRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingFeeRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
